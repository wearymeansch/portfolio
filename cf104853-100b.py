#в задаче рассматривается все пути кузнечика, начинающиеся на столбике l и заканчивающиеся на столбике r, такие что l<=r, т.е. формально считается и путь, начинающийся и заканчивающийся на одном и том же столбике
import bisect
def get_mx(l,r):#функция предполагает, что предварительно заполнены списки максимумов mx
    #по одному в mx[0], по два в mx[1], по четыре в mx[2] и т.д. и находит максимум среди всех эл-тов
    #списка a из диапазона индексов [l,r)
    t = logs[r - l]#заносим в t округленный вниз логарифм кол-ва столбиков, по которым берем максимум 
    return max(mx[t][l], mx[t][r - (1 << t)])#возвращаем максимум среди списка a из диапазона индексов [l,r)

def get_mn(l,r):#функция предполагает, что предварительно заполнены списки минимумов mn
    #по одному в mn[0], по два в mn[1], по четыре в mn[2] и т.д. и находит минимум среди всех эл-тов
    #списка T из диапазона индексов [l,r)
    t = logs[r - l]#заносим в t округленный вниз логарифм кол-ва столбиков, по которым берем максимум 
    return min(mn[t][l], mn[t][r - (1 << t)])#возвращаем минимум среди списка максимумов по k 
    #из диапазона индексов [l,r)

n,k = [int(i) for i in input().split()]#чтение входных значений n (общее кол-во столбиков) и
#k (максимальная длина прыжка) из 1-ой строки
a = [int(i) for i in input().split()]#чтение высот столбиков из 2-ой строки
INF = int(1.1e9);

logs=[0]*(n+1)#массив округленных вниз логарифмов по основанию 2 от индекса
for i in range(2,n+1):#цикл для заполнения округленных вниз логарифмов по основанию 2 от индекса
    logs[i] = logs[i >> 1] + 1#берется логарифм от вдвое меньшего числа и прибавляется 1
LMAXN=logs[n]+1#требуемое кол-во уровней в списке списков
mx=[[0]*n for i in range(LMAXN)]#заполняем нулями список списков максимумов по степеням 2-ки
mx[0]=a#в нулевом списке максимумы по одному, т.е просто эл-ты a, лишние эл-ты - нули
for d in range(1,LMAXN):#перебираем остальные списки(максимумы по 2,4 и т.д.), в списке с номером
    #d берутся максимумы по 2 в степени d 
    st2=1<<(d-1)#считаем степень 2-ки (по сколько брались максимумы) в предыдущем списке
    for i in range(0,n-st2*2+1):#перебор номеров эл-тов очередного списка максимумов
        mx[d][i]=max(mx[d-1][i], mx[d-1][i+st2])#вычисляем максимум по вдвое большему диапазону
b=[INF]*n#список максимумов по k, с точки зрения прыжков кузнечика, можно понимать смысл элемента b[i]
#как наиболее высокий столбик, на который можно прыгнуть со столбика i-1 
for i in range(n-k+1):
    b[i]=get_mx(i, i+k) #get_mx(i, i+k) возвращает максимум по k, начиная с i столбца
nonactiveB=list(range(-1, n+1))#эл-ты массива nonactiveB показывают, какие эл-ты массива b пока еще
#не используются в качестве вспомогательных (промежуточных) столбиков поскольку они имеют слишком 
#маленькие значения
events=[]#массив events показывает в каком порядке будут использоваться эл-ты массивов a и b. Сначала
#рассматриваются самые высокие столбики из обоих массивов, причем сначала рассматриваются эл-ты
#массива а, а затем эл-ты массива b с одинаковой высотой. Эл-ты массива являются парами, причем 1-ый
#эл-т пары показывает высоту столбика, а 2-ой эл-т пары показывает номер столбика в массиве а или b,
#причем индексы эл-тов массива а хранятся непосредственно, а индексы эл-тов массива b хранятся
#в дополнительном коде
for i in range(n):
    events.append((a[i], i))
    events.append((b[i], ~i))
events.sort(reverse=True)
ans = 0
def getPrev(x):
    return nonactiveB[bisect.bisect_right(nonactiveB,x)-1]#upper_bound в set возвращает итератор, указывающий
#на первый элемент, который больше значения х, в питоне анaлогом является функция bisect_right.
#getPrev возвращает ссылку на значение x (или ближайшее, которое меньше его, при отсутствии x) 
#в списке nonactiveB, возможна ошибка, если x меньше всех значений в nonactiveB
def getNext(x): 
    return nonactiveB[bisect.bisect_left(nonactiveB,x)]#возвращение ссылки на значение x (или ближайшее,
#которое больше его, при отсутствии x) в списке nonactiveB, возможна ошибка, если x больше всех
#значений в nonactiveB
activeA=[]#смысл массива activeA заключается в том, что в него помещаются столбики, которые уже могут 
#использоваться в качестве начальных и конечных
def getA(l,r):#функция getA возвращает кол-во эл-тов, находящихся в отсортированном массиве activeA,
#которые >= l, но < r 
    return bisect.bisect_left(activeA,r) - bisect.bisect_left(activeA,l)
 
for x,t in events:
    if (t < 0):
      t = ~t
      #assert(b[t] == x);
      nonactiveB.remove(t)
      fromm = getPrev(t)
      to = getNext(t)
      #assert(from <= t);
      #assert(to >= t);
      #print(x, t, ans, fromm, to)
      ans += x * getA(fromm + 1, t + 1) * getA(t, to)#по видимому, здесь подсчитывается кол-во
#путей, в которых столбик с индексом t будет наименьшим (в качестве промежуточного?). Соответственно,
#смысл getA(from + 1, t + 1) заключается в подсчете, со скольки столбиков при этом может
#начинаться маршрут, а смысл getA(t, to) заключается в подсчете столбиков, на которых при этом
#может заканчиваться маршрут
    else:
      #assert(a[t] == x);
      bisect.insort(activeA,t)
      fromm = getPrev(t)
      to = getNext(t)
      #print(x, t, ans, fromm, to)
      if (fromm + 1 <= to): #условие можно заменить на from<to
        ans += x * getA(fromm + 1, to)
print(ans)
 
