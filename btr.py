import sys
def height(r):
    if r==None:
        return 0
    else:
        return max(height(r[1]), height(r[2]))+1
def size(r):
    if r==None:
        return 0
    else:
        return size(r[1])+size(r[2])+1
def insert(s,zn):
    if s == None:
        s=[zn, None, None]#вставка числа в корень
    elif s[0]>zn:
        s[1]=insert(s[1], zn)#вставка числа в левую ветку
    else:
        s[2]=insert(s[2], zn)#вставка числа в правую ветку
    return s
#здесь функция insert является рекурсивной, поскольку она вызывает сама себя. У рекурсивных функций
#обязательно должен быть базовый случай, который вычисляется без обращения функции к самой себе.
#Здесь таким базовым случаем является строчка 3. Базовый случай всегда должен достигаться за конечное
#кол-во вызовов функции, иначе может возникнуть бесконечная рекурсия (программа подвиснет).
#В Питоне для защиты от бесконечной рекурсии сделан контроль количества незавершенных вызовов функции.
#По умолчанию допускается не более 1000 незавершенных вызовов функции. Кол-во незавершенных вызовов
#рекурсивной функции ограничивается из-за того, что каждый незавершенный вызов рекурсивной функции
#требует дополнительной памяти для локальных переменных и ссылки на предыдущий незавершенный
#вызов функции, в какое место функции нужно возвращаться.
#В питоне при необходимости можно увеличить максимально допустимое кол-во незавершенных рекурсивных
#вызовов, используя функцию setcursionlimit из модуля sys. Узнать текущую глубину рекурсии можно
#функцией getrecursionlimit
def rotateleft(r):#поворот влево. r - это эл-т, который условно считается старым корнем, а новым корнем
#станет его правый ребёнок 
    if r!= None and r[2] != None:#проверяем, что есть корень и его правый ребёнок, иначе оставляем дерево неизменным
        nr=r[2]#запоминаем ссылку на новый корень
        r[2]=nr[1]#бывший левый ребёнок нового корня станет правым ребёнком старого корня 
        nr[1]=r#левым ребёнком нового корня станет старый корень
        r=nr#исправляем ссылку r на новый корень
    return r
def rotateright(r):#поворот вправо. r - это эл-т, который условно считается старым корнем, а новым корнем
#станет его левый ребёнок 
    if r!= None and r[1] != None:#проверяем, что есть корень и его левый ребёнок, иначе оставляем дерево неизменным
        nr=r[1]#запоминаем ссылку на новый корень
        r[1]=nr[2]#бывший правый ребёнок нового корня станет левым ребёнком старого корня 
        nr[2]=r#правым ребёнком нового корня станет старый корень
        r=nr#исправляем ссылку r на новый корень
    return r
print(sys.getrecursionlimit())
sys.setrecursionlimit(10000)
s=None
for i in range(10):
    ch1=int(input())
    s=insert(s, ch1)
    print(s)
    print(height(s), size(s))
