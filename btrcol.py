import sys
def height(r):
    if r==None:
        return 0
    else:
        return max(height(r[1]), height(r[2]))+1
def size(r):
    if r==None:
        return 0
    else:
        return size(r[1])+size(r[2])+1
def make_insert(s,zn):#функция вызывается для вставки в корень s
    s, db=insert(s, zn)
    if s[3]=='r':#аналог случая 1 в Википедии
        s[3]='b'
    return s
def insert(s,zn):#функция вызывается для вставки в произвольное место дерева s
    dopblack=0
    if s == None:#аналог случая 2 в Википедии
        s=[zn, None, None,"r"]#создание нового эл-та, который к чему-нибудь будет привязан
    elif s[0]>zn:
        s[1],db=insert(s[1], zn)#вставка числа в левую ветку
        if s[3]=='r' and s[1][3]=='r':
            s[3]='b'
            dopblack+=1
        elif s[2] and s[2][3]=='r' and db>0:#перекраска красного дяди в черный цвет
            s[2][3]='b'
            s[3]='r'
            dopblack=0
    else:
        s[2],db=insert(s[2], zn)#вставка числа в правую ветку
        if s[3]=='r' and s[2][3]=='r':
            s[3]='b'
            dopblack+=1
        elif s[1] and s[1][3]=='r' and db>0:#перекраска красного дяди в черный цвет
            s[1][3]='b'
            s[3]='r'
            dopblack=0
    return s, dopblack
#здесь функция insert является рекурсивной, поскольку она вызывает сама себя. У рекурсивных функций
#обязательно должен быть базовый случай, который вычисляется без обращения функции к самой с:ебе.
#Здесь таким базовым случаем является строчка 3. Базовый случай всегда должен достигаться за конечное
#кол-во вызовов функции, иначе может возникнуть бесконечная рекурсия (программа подвиснет).
#В Питоне для защиты от бесконечной рекурсии сделан контроль количества незавершенных вызовов функции.
#По умолчанию допускается не более 1000 незавершенных вызовов функции. Кол-во незавершенных вызовов
#рекурсивной функции ограничивается из-за того, что каждый незавершенный вызов рекурсивной функции
#требует дополнительной памяти для локальных переменных и ссылки на предыдущий незавершенный
#вызов функции, в какое место функции нужно возвращаться.
#В питоне при необходимости можно увеличить максимально допустимое кол-во незавершенных рекурсивных
#вызовов, используя функцию setcursionlimit из модуля sys. Узнать текущую глубину рекурсии можно
#функцией getrecursionlimit
def rotateleft(r):#поворот влево. r - это эл-т, который условно считается старым корнем, а новым корнем
#станет его правый ребёнок 
    if r!= None and r[2] != None:#проверяем, что есть корень и его правый ребёнок, иначе оставляем дерево неизменным
        nr=r[2]#запоминаем ссылку на новый корень
        r[2]=nr[1]#бывший левый ребёнок нового корня станет правым ребёнком старого корня 
        nr[1]=r#левым ребёнком нового корня станет старый корень
        r=nr#исправляем ссылку r на новый корень
    return r
def rotateright(r):#поворот вправо. r - это эл-т, который условно считается старым корнем, а новым корнем
#станет его левый ребёнок 
    if r!= None and r[1] != None:#проверяем, что есть корень и его левый ребёнок, иначе оставляем дерево неизменным
        nr=r[1]#запоминаем ссылку на новый корень
        r[1]=nr[2]#бывший правый ребёнок нового корня станет левым ребёнком старого корня 
        nr[2]=r#правым ребёнком нового корня станет старый корень
        r=nr#исправляем ссылку r на новый корень
    return r
print(sys.getrecursionlimit())
sys.setrecursionlimit(10000)
s=None
ch = [4,2,8,1,3,6,9,5,7,10]
for ch1 in ch:
    #ch1=int(input())
    s=make_insert(s, ch1)
    print(s)
    print(height(s), size(s))
##s=rotateleft(s)
##print(s)
##print(height(s), size(s))
##s[2]=rotateleft(s[2])
##print(s)
##print(height(s), size(s))
##s[2][2]=rotateleft(s[2][2])
##print(s)
##print(height(s), size(s))
##s[2][2][2]=rotateleft(s[2][2][2])
##print(s)
##print(height(s), size(s))
##s=rotateleft(s)
##print(s)
##print(height(s), size(s))
##s[2]=rotateleft(s[2])
##print(s)
##print(height(s), size(s))
