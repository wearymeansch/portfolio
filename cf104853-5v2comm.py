#в задаче рассматривается все пути кузнечика, начинающиеся на столбике l и заканчивающиеся на столбике r, такие что l<=r, т.е. формально считается и путь, начинающийся и заканчивающийся на одном и том же столбике
n,k = [int(i) for i in input().split()]
a = [int(i) for i in input().split()]
s=0
if k>1:
    sf=[0]*n
    for l in range(n):
        for r in range(l,n):
            sf[r]=a[r]
            if l<r:
                lp=max(r-k,l)
                maxp=max(sf[lp:r])
                sf[r]=min(maxp,sf[r])
                #print(l,r,lp,maxp,sf[r])
            s+=sf[r]
        #print(sf[l:])
else:
    left = [0]*len(a)
    right = [0]*len(a)
    for i in range(len(a)):
        left[i]=i-1
        while left[i]>=0 and a[left[i]]>a[i]:
            left[i]=left[left[i]]
    for i in range(len(a)-1,-1,-1):
        right[i]=i+1
        while right[i] < len(a) and a[right[i]] >= a[i]:
            right[i] = right[right[i]]
    for i in range(len(a)):
        s += a[i]*(i-left[i])*(right[i]-i)#берем высоту столбика a[i] и умножаем на кол-во путей в которых этот столбик будет минимальным. При этом в left[i] содержится номер самого близкого более левого столбика, который по высоте не больше а[i], либо -1, если все столбики левее больше а[i]. В результате разница i-left[i] показывает сколько есть столбиков слева, включая столбик i, с которых может начинаться такой путь кузнечика, что столбик i будет самым низким от начала пути. При этом в right[i] содержится номер самого близкого более правого столбика, который по высоте больше а[i], либо n, если все столбики правее не меньше а[i]. В результате разница right[i]-i показывает сколько есть столбиков справа, включая столбик i, на которых может заканчиваться такой путь кузнечика, что не будет более низких столбиков, чем i, до конца пути. Таким образом, произведение (i-left[i])*(right[i]-i) умножает кол-во возможных начал путей на кол-во возможных концов путей, для путей кузнечика, в которых столбик i самый низкий. 
print(s)
