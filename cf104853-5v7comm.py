#в задаче рассматривается все пути кузнечика, начинающиеся на столбике l и заканчивающиеся на столбике r, такие что l<=r, т.е. формально считается и путь, начинающийся и заканчивающийся на одном и том же столбике
def get_mx(l,r):#функция предполагает, что предварительно заполнены списки максимумов mx
    #по одному в mx[0], по два в mx[1], по четыре в mx[2] и т.д. и находит максимум среди всех эл-тов
    #списка a из диапазона индексов [l,r)
    t = logs[r - l]#заносим в t округленный вниз логарифм кол-ва столбиков, по которым берем максимум 
    return max(mx[t][l], mx[t][r - (1 << t)])#возвращаем максимум среди списка a из диапазона индексов [l,r)

def get_mn(l,r):#функция предполагает, что предварительно заполнены списки минимумов mn
    #по одному в mn[0], по два в mn[1], по четыре в mn[2] и т.д. и находит минимум среди всех эл-тов
    #списка a из диапазона индексов [l,r)
    t = logs[r - l]#заносим в t округленный вниз логарифм кол-ва столбиков, по которым берем максимум 
    return min(mn[t][l], mn[t][r - (1 << t)])#возвращаем минимум среди списка максимумов по k 
    #из диапазона индексов [l,r)

n,k = [int(i) for i in input().split()]#чтение входных значений n (общее кол-во столбиков) и k (максимальная длина прыжка) из 1-ой строки
a = [int(i) for i in input().split()]#чтение высот столбиков из 2-ой строки
s=0
if k>1:
    LMAXN=18#максимальный округленный вверх логарифм по основанию 2 от n, при условии что n<=200000
    logs=[0]*(n)#массив округленных вниз логарифмов по основанию 2 от индекса
    for i in range(2,n):#цикл для заполнения округленных вниз логарифмов по основанию 2 от индекса
        logs[i] = logs[i >> 1] + 1#берется логарифм от вдвое меньшего числа и прибавляется 1
    mx=[[0]*n for i in range(LMAXN)]#заполняем нулями список списков максимумов по степеням 2-ки
    #с корректным заполнением лишних эл-тов
    mx[0][:n]=a#в нулевом списке максимумы по одному, т.е просто эл-ты a, лишние эл-ты - нули
    for d in range(1,LMAXN):#перебираем остальные списки(максимумы по 2,4 и т.д.), в списке с номером d берутся максимумы по 2 в степени d 
        st2=1<<(d-1)#считаем степень 2-ки (по сколько брались максимумы) в предыдущем списке
        for i in range(0,n-st2*2+1):#перебор номеров эл-тов очередного списка максимумов
            #чтобы не брать лишних можно nup заменить на n
            mx[d][i]=max(mx[d-1][i], mx[d-1][i+st2])#вычисляем максимум по вдвое большему диапазону
    T=[]#список максимумов по k
    for i in range(n-k+1):
        T.append(get_mx(i, i+k)) #get_mx(i, i+k) возвращает максимум по k, начиная с i столбца
    ##print("mx")
    ##for i in range(LMAXN):
    ##    print(i,mx[i][:nup])
    ##print("T")
    ##print(T)
    mn=[[0]*len(T) for i in range(LMAXN)]#заполняем нулями список списков минимумов по степеням 2-ки
    mn[0][:len(T)]=T#в списке mn[0] максимумы по k, среди них найдутся минимумы, лишние эл-ты - нули
    for d in range(1,LMAXN):#перебираем остальные списки(минимумы по 2,4 и т.д. из максимумов по k)
        st2=1<<(d-1)#считаем степень 2-ки (по сколько брались минимумы) в предыдущем списке
        for i in range(0,len(T)-st2*2+1):#перебор номеров эл-тов очередного списка минимумов 
            mn[d][i]=min(mn[d-1][i], mn[d-1][i+st2])#вычисляем минимум по вдвое большему диапазону
    for i in range(n):
        for j in range(i,n):
            if (i + k >= j):
                s += min(a[i], a[j])
            else:
                s += min(get_mn(i+1, j - k + 1), min(a[i], a[j]))
            #get_mn(i+1, j - k + 1) возвращает минимум из диапазона [i+1,j-k+1) (среди значений T,
            #которые представляют собой максимумы по k). По существу здесь ищется минимум
            #среди максимумов для всех групп из k подряд идущих столбиков таких, что каждая
            #группа из k столбиков принадлежит диапазону (i,j)
    ##print("mn")
    ##for i in range(LMAXN):
    ##    print(i,mn[i][:nup])
else:
    left = [0]*len(a)
    right = [0]*len(a)
    for i in range(len(a)):
        left[i]=i-1
        while left[i]>=0 and a[left[i]]>a[i]:
            left[i]=left[left[i]]
    for i in range(len(a)-1,-1,-1):
        right[i]=i+1
        while right[i] < len(a) and a[right[i]] >= a[i]:
            right[i] = right[right[i]]
    for i in range(len(a)):
        s += a[i]*(i-left[i])*(right[i]-i)#берем высоту столбика a[i] и умножаем на кол-во путей в которых этот столбик будет минимальным. При этом в left[i] содержится номер самого близкого более левого столбика, который по высоте не больше а[i], либо -1, если все столбики левее больше а[i]. В результате разница i-left[i] показывает сколько есть столбиков слева, включая столбик i, с которых может начинаться такой путь кузнечика, что столбик i будет самым низким от начала пути. При этом в right[i] содержится номер самого близкого более правого столбика, который по высоте больше а[i], либо n, если все столбики правее не меньше а[i]. В результате разница right[i]-i показывает сколько есть столбиков справа, включая столбик i, на которых может заканчиваться такой путь кузнечика, что не будет более низких столбиков, чем i, до конца пути. Таким образом, произведение (i-left[i])*(right[i]-i) умножает кол-во возможных начал путей на кол-во возможных концов путей, для путей кузнечика, в которых столбик i самый низкий. 
print(s)
