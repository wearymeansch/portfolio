def insert(s,zn):
    if s == None or zn<s[0]:
        s=[zn, s]#вставка числа в начало 
    else:
        sl=s
        while sl[1]!=None and sl[1][0]<zn:
            sl=sl[1]#сдвиг ссылки sl на следующий вложенный список
        sl[1]=[zn, sl[1]]#вставка числа, если не в начало
    return s
s=None
for i in range(4):
    ch1=int(input())
    s=insert(s, ch1)
    print(s)
#в данном примере организуется отсортированная последовательность чисел с
#использованием списков, ссылающихся на другие списки. Каждый мини-список
#содержит в нулевом эл-те числовое значение, а в 1-ом эл-те ссылку на следующий
#список или значение None, когда следующего списка нет. В данном примере очень
#быстро выполняется вставка нового числа (операторы s=[zn, s] и
#sl[1]=[zn, sl[1]]). Однако, чтобы найти место, куда вставляется новое число,
#крутится цикл while sl[1]!=None and sl[1][0]<zn: , который повторяется до
#n раз, где n-количество чисел в списке, в среднем n/2 раз.
#таким образом, хотя ускорилась операция вставки, до сложности равной 1
#операция поиска места вставки наоборот замедлилась до сложности порядка n

#существуют разные варианты организации ссылок в списках, например, можно
#организовать отсортированный список из n чисел, так, чтобы сложность и
#операции поиска и операции вставки была порядка sqrt(n). Для этого можно
#организовать список длиной sqrt(n), в котором будут содержаться ссылки
#на отсортированные списки с числами, каждый из которых имеет длину порядка
#sqrt(n), причем каждый следующий список с числами содержит числа, идущие после
#предыдущего списка

#Однако, такой подход, со сложностью sqrt(n) является полумерой, которая позволяет улучшить
#сложность программы, но может не позволить пройти предельные тесты
#для прохождения всех тестов желательно, чтобы все операции (вставка, удаление, поиск места
#для вставки или поиск удаляемого эл-та) выполнялись со сложностью log2(n)
#в литературе иногда опускают основание логарифма и пишут просто log(n)
#это связано с тем, что в грубой оценки сложности пренебрегают домножением на константу
#например, сложность порядка n и сложность порядка n/2 считают практически равноценной
#на самом деле, логарифмы с разными основаниями тоже отличаются друг от друга всего лишь на
#константу. Например, log4(n)=log2(n)/log2(4)=log2(n)/2

#для эффективной организации всех перечисленных операций со сложностью log2(n) могут использоваться
#бинарные деревья
