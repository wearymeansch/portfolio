#в задаче рассматривается все пути кузнечика, начинающиеся на столбике l и заканчивающиеся на столбике r, такие что l<=r, т.е. формально считается и путь, начинающийся и заканчивающийся на одном и том же столбике
def get_mx(l,r):#функция предполагает, что предварительно заполнены списки максимумов mx
    #по одному в mx[0], по два в mx[1], по четыре в mx[2] и т.д. и находит максимум среди всех эл-тов
    #списка a из диапазона индексов [l,r)
    t = logs[r - l]#заносим в t округленный вниз логарифм кол-ва столбиков, по которым берем максимум 
    return max(mx[t][l], mx[t][r - (1 << t)])#возвращаем максимум среди списка a из диапазона индексов [l,r)

def get_mn(l,r):#функция предполагает, что предварительно заполнены списки минимумов mn
    #по одному в mn[0], по два в mn[1], по четыре в mn[2] и т.д. и находит минимум среди всех эл-тов
    #списка a из диапазона индексов [l,r)
    t = logs[r - l]#заносим в t округленный вниз логарифм кол-ва столбиков, по которым берем максимум 
    return min(mn[t][l], mn[t][r - (1 << t)])#возвращаем минимум среди списка максимумов по k 
    #из диапазона индексов [l,r)

n,k = [int(i) for i in input().split()]#чтение входных значений n (общее кол-во столбиков) и k (максимальная длина прыжка) из 1-ой строки
a = [int(i) for i in input().split()]#чтение высот столбиков из 2-ой строки
s=0
if k>1:
    LMAXN=18#максимальный округленный вверх логарифм по основанию 2 от n, при условии что n<=200000
    MAXN=2**18#максимальный размер списка округленный вверх до ближайшей степени двойки
    logs=[0]*(MAXN+1)#массив округленных вниз логарифмов по основанию 2 от индекса
    logsup=[0]*(MAXN+1)#массив округленных вверх логарифмов по основанию 2 от индекса
    logs[1] = 0;#значение логарифма от единицы
    for i in range(2,MAXN+1):#цикл для заполнения округленных вниз логарифмов по основанию 2 от индекса
        logs[i] = logs[i >> 1] + 1#берется логарифм от вдвое меньшего числа и прибавляется 1
    st2=1#степень 2 вначале нулевая
    p=0#очередное значение округленного вверх логарифма по основанию 2 от индекса
    for i in range(1,MAXN+1):#цикл для заполнения округленных вверх логарифмов по основанию 2 от индекса
        logsup[i]=p#запоминаем очередной логарифм в списке 
        if i>=st2:#если дошли до точной степени 2-ки
            st2*=2#домножаем степень двойки на 2
            p+=1#при этом показатель степени увеличивается на 1
    nup=(1<<logsup[n])#запоминаем в nup округленное вверх до ближайшей степени двойки n
##    mx=[[0]*(MAXN+1) for i in range(LMAXN)]#заполняем нулями список списков максимумов по степеням 2-ки
##    mx[0][:n]=a#в нулевом списке максимумы по одному, т.е просто эл-ты a 
##    for d in range(1,LMAXN):#перебираем остальные списки(максимумы по 2,4 и т.д.)
##        st2=1<<(d-1)#считаем степень 2-ки (по сколько брались максимумы) в предыдущем списке
##        for i in range(0,n-st2+1):#перебор номеров эл-тов очередного списка максимумов 
##            mx[d][i]=max(mx[d-1][i], mx[d-1][i+st2])#вычисляем максимум по вдвое большему диапазону
    #из-за некорректного перебора номеров i в предыдущих 2-ух строчках возможно неправильное заполнение некоторых эл-тов
    #однако эти эл-ты являются лишними и не влияют в итоге на работу программы
    mx=[[0]*(MAXN+1) for i in range(LMAXN)]#заполняем нулями список списков максимумов по степеням 2-ки
    #с корректным заполнением лишних эл-тов
    mx[0][:n]=a#в нулевом списке максимумы по одному, т.е просто эл-ты a, лишние эл-ты - нули
    for d in range(1,LMAXN):#перебираем остальные списки(максимумы по 2,4 и т.д.), в списке с номером d берутся максимумы по 2 в степени d 
        st2=1<<(d-1)#считаем степень 2-ки (по сколько брались максимумы) в предыдущем списке
        for i in range(0,n-st2*2+1):#перебор номеров эл-тов очередного списка максимумов
            #чтобы не брать лишних можно nup заменить на n
            mx[d][i]=max(mx[d-1][i], mx[d-1][i+st2])#вычисляем максимум по вдвое большему диапазону
    ##for i in range(17):
    ##    print(i,logs[i],logsup[i])
    T=[]#список максимумов по k
    for i in range(n-k+1):
        T.append(get_mx(i, i+k)) #get_mx(i, i+k) возвращает максимум по k, начиная с i столбца
    ##print("mx")
    ##for i in range(LMAXN):
    ##    print(i,mx[i][:nup])
    ##print("mxc")
    ##for i in range(LMAXN):
    ##    print(i,mxc[i][:nup])
    ##print("T")
    ##print(T)
    mn=[[0]*(MAXN+1) for i in range(LMAXN)]#заполняем нулями список списков минимумов по степеням 2-ки
    mn[0][:len(T)]=T#в списке mn[0] максимумы по k, среди них найдутся минимумы, лишние эл-ты - нули
    for d in range(1,LMAXN):#перебираем остальные списки(минимумы по 2,4 и т.д. из максимумов по k)
        st2=1<<(d-1)#считаем степень 2-ки (по сколько брались минимумы) в предыдущем списке
        for i in range(0,n-st2+1):#перебор номеров эл-тов очередного списка минимумов 
            mn[d][i]=min(mn[d-1][i], mn[d-1][i+st2])#вычисляем минимум по вдвое большему диапазону
    for i in range(n):
        for j in range(i,n):
            if (i + k >= j):
                s += min(a[i], a[j])
            else:
                s += min(get_mn(i+1, j - k + 1), min(a[i], a[j]))
            #get_mn(i, j - k + 2) возвращает минимум из диапазона [i,j-k+2) (среди значений T,
            #которые представляют собой максимумы по k).
            #не совсем ясно прибавление 2-ки в выражении j-k+2. При k = 1 это приводит к тому,
            #что будут браться минимумы среди значений T в диапазоне [i,j], которые совпадают
            #с минимумами по значениям a из тех же диапазонов, и тогда брать дополнительно
            #min(a[i], a[j]) не нужно. Таким образом, при k=1 можно брать get_mn(i+1, j-k+1).
            #При k = 2 это приводит к тому, что будут браться минимумы
            #среди значений T в диапазоне [i,j-1], но не ясен смысл взятия T[j-1], ведь высота
            #столбика a[j-1] уже учтена в массиве T[j-2], если он выше, чем a[j-2], а если столбик
            #а[j-1]<a[j-2], то a[j-1] вообще не надо использовать, а надо прыгать сразу с j-2 на j
            #(в принципе j-1 в этом случае можно использовать, если он выше j, но учет максимума
            #из j-1 и j, который содержится в T[j-1], в этом случае все равно не имеет смысла,
            #поскольку столбик j ниже). При k=2 возможно также не надо брать в get_mn() столбик i,
            #поскольку, если a[i+1]>a[i], то в T[i] будет a[i+1], но учет этого значения не имеет
            #смысла, поскольку все равно надо учитывать более низкий начальный столбик a[i].
            #Если же a[i]>a[i+1], то интерес представляет T[i+1], поскольку в нем будет содержаться
            #больший из столбиков i+1 и i+2, на которые можно прыгнуть со столбика i, а T[i] будет
            #содержать a[i], который все равно будет учтен отдельно в минимуме.
            #Таким образом, и при k=2 можно брать get_mn(i+1, j-k+1)
            #При k=3 это приводит к тому, что будут браться минимумы среди значений T в
            #диапазоне [i,j-2], но здесь ситуация еще более странная, поскольку T[j-2] будет
            #содержать максимум по трем столбикам:a[j-2], a[j-1], a[j]. Однако, на столбик j
            #можно прыгнуть с трех предыдущих столбиков:j-3, j-2, j-1 и интересен максимум по этим
            #трем столбикам, а столбик j будет все равно учтен в минимуме, если он ниже какого-то 
            #из трех предыдущих, а если столбик j выше всех трех предыдущих, то в T[j-2] будет
            #именно он, но его учет не представляет интереса, поскольку в T[j-3] будет максимум
            #по трем предыдущим столбикам, которые меньше. Аналогично нет смысла брать в get_mn
            #столбик i, поскольку со столбика i можно прыгнуть на 3 следующих столбика
            #i+1, i+2, i+3 и интерес представляет максимум по этим трем столбикам в T[i+1], а
            #в T[i] будет содержаться максимум по столбикам i, i+1, i+2. Если a[i]<какого-то из
            #следующих трех столбиков, то все равно в минимуме будет учтено a[i], а не T[i].
            #Если же a[i]>всех трех следующих столбиков, то интерес представляет T[i+1],
            #поскольку в нем будет содержаться больший из столбиков i+1, i+2, i+3 на которые
            #можно прыгнуть со столбика i, а T[i] будет содержать a[i], который все равно
            #будет учтен отдельно в минимуме.
            #Таким образом, и при k=3 можно брать get_mn(i+1, j-k+1)
            #При произвольном k>3 это приводит к тому, что будут браться минимумы среди значений T в
            #диапазоне [i,j-k+1], но T[j-k+1] будет
            #содержать максимум по k столбикам:a[j-k+1], ..., a[j]. Однако, на столбик j
            #можно прыгнуть с k предыдущих столбиков:j-k, ..., j-1 и интересен максимум по этим
            #k столбикам, а столбик j будет все равно учтен в минимуме, если он ниже какого-то 
            #из k предыдущих, а если столбик j выше всех k предыдущих, то в T[j-k+1] будет
            #именно он, но его учет не представляет интереса, поскольку в T[j-k] будет максимум
            #по k предыдущим столбикам, которые меньше. Аналогично нет смысла брать в get_mn
            #столбик i, поскольку со столбика i можно прыгнуть на k следующих столбиков
            #i+1, ..., i+k и интерес представляет максимум по этим k столбикам в T[i+1], а
            #в T[i] будет содержаться максимум по столбикам i, ..., i+k-1. Если a[i]<какого-то из
            #следующих k столбиков, то все равно в минимуме будет учтено a[i], а не T[i].
            #Если же a[i]>всех k следующих столбиков, то интерес представляет T[i+1],
            #поскольку в нем будет содержаться больший из столбиков i+1, ..., i+k на которые
            #можно прыгнуть со столбика i, а T[i] будет содержать a[i], который все равно
            #будет учтен отдельно в минимуме.
            #Таким образом, и при k>3 можно брать get_mn(i+1, j-k+1)
    ##print("mn")
    ##for i in range(LMAXN):
    ##    print(i,mn[i][:nup])
else:
    left = [0]*len(a)
    right = [0]*len(a)
    for i in range(len(a)):
        left[i]=i-1
        while left[i]>=0 and a[left[i]]>a[i]:
            left[i]=left[left[i]]
    for i in range(len(a)-1,-1,-1):
        right[i]=i+1
        while right[i] < len(a) and a[right[i]] >= a[i]:
            right[i] = right[right[i]]
    for i in range(len(a)):
        s += a[i]*(i-left[i])*(right[i]-i)#берем высоту столбика a[i] и умножаем на кол-во путей в которых этот столбик будет минимальным. При этом в left[i] содержится номер самого близкого более левого столбика, который по высоте не больше а[i], либо -1, если все столбики левее больше а[i]. В результате разница i-left[i] показывает сколько есть столбиков слева, включая столбик i, с которых может начинаться такой путь кузнечика, что столбик i будет самым низким от начала пути. При этом в right[i] содержится номер самого близкого более правого столбика, который по высоте больше а[i], либо n, если все столбики правее не меньше а[i]. В результате разница right[i]-i показывает сколько есть столбиков справа, включая столбик i, на которых может заканчиваться такой путь кузнечика, что не будет более низких столбиков, чем i, до конца пути. Таким образом, произведение (i-left[i])*(right[i]-i) умножает кол-во возможных начал путей на кол-во возможных концов путей, для путей кузнечика, в которых столбик i самый низкий. 
print(s)
