def get_mx(l,r):#функция предполагает, что предварительно заполнены списки максимумов mx
    #по одному в mx[0], по два в mx[1], по четыре в mx[2] и т.д. и находит максимум среди всех эл-тов
    #списка a из диапазона индексов [l,r)
    t = logs[r - l]#заносим в t округленный вниз логарифм кол-ва столбиков, по которым берем максимум 
    return max(mx[t][l], mx[t][r - (1 << t)])#возвращаем максимум среди списка a из диапазона индексов [l,r)

def get_mn(l,r):#функция предполагает, что предварительно заполнены списки максимумов mx
    #по одному в mx[0], по два в mx[1], по четыре в mx[2] и т.д. и находит максимум среди всех эл-тов
    #списка a из диапазона индексов [l,r)
    t = logs[r - l]#заносим в t округленный вниз логарифм кол-ва столбиков, по которым берем максимум 
    return min(mn[t][l], mn[t][r - (1 << t)])#возвращаем максимум среди списка a из диапазона индексов [l,r)

n,k = [int(i) for i in input().split()]#чтение входных значений n (общее кол-во столбиков) и k (максимальная длина прыжка) из 1-ой строки
a = [int(i) for i in input().split()]#чтение высот столбиков из 2-ой строки
LMAXN=18#максимальный округленный вверх логарифм по основанию 2 от n, при условии что n<=200000
MAXN=2**18#максимальный размер списка округленный вверх до ближайшей степени двойки
logs=[0]*(MAXN+1)#массив округленных вниз логарифмов по основанию 2 от индекса
logsup=[0]*(MAXN+1)#массив округленных вверх логарифмов по основанию 2 от индекса
logs[1] = 0;#значение логарифма от единицы
for i in range(2,MAXN+1):#цикл для заполнения округленных вниз логарифмов по основанию 2 от индекса
    logs[i] = logs[i >> 1] + 1#берется логарифм от вдвое меньшего числа и прибавляется 1
st2=1#степень 2 вначале нулевая
p=0#очередное значение округленного вверх логарифма по основанию 2 от индекса
for i in range(1,MAXN+1):#цикл для заполнения округленных вверх логарифмов по основанию 2 от индекса
    logsup[i]=p#запоминаем очередной логарифм в списке 
    if i>=st2:#если дошли до точной степени 2-ки
        st2*=2#домножаем степень двойки на 2
        p+=1#при этом показатель степени увеличивается на 1
nup=(1<<logsup[n])#запоминаем в nup округленное вверх до ближайшей степени двойки n
mx=[[0]*(MAXN+1) for i in range(LMAXN)]#заполняем нулями список списков максимумов по степеням 2-ки
mx[0][:n]=a#в нулевом списке максимумы по одному, т.е просто эл-ты a 
for d in range(1,LMAXN):#перебираем остальные списки(максимумы по 2,4 и т.д.)
    st2=1<<(d-1)#считаем степень 2-ки (по сколько брались максимумы) в предыдущем списке
    for i in range(0,n-st2+1):#перебор номеров эл-тов очередного списка максимумов 
        mx[d][i]=max(mx[d-1][i], mx[d-1][i+st2])#вычисляем максимум по вдвое большему диапазону
#из-за некорректного перебора номеров i в предыдущих 2-ух строчках возможно неправильное заполнение некоторых эл-тов
#однако эти эл-ты являются лишними и не влияют в итоге на работу программы
mxc=[[0]*(MAXN+1) for i in range(LMAXN)]#заполняем нулями список списков максимумов по степеням 2-ки
#с корректным заполнением лишних эл-тов
mxc[0][:n]=a#в нулевом списке максимумы по одному, т.е просто эл-ты a, лишние эл-ты - нули
for d in range(1,LMAXN):#перебираем остальные списки(максимумы по 2,4 и т.д.), в списке с номером d берутся максимумы по 2 в степени d 
    st2=1<<(d-1)#считаем степень 2-ки (по сколько брались максимумы) в предыдущем списке
    for i in range(0,nup-st2*2+1):#перебор номеров эл-тов очередного списка максимумов
        #чтобы не брать лишних можно nup заменить на n
        mxc[d][i]=max(mxc[d-1][i], mxc[d-1][i+st2])#вычисляем максимум по вдвое большему диапазону
##for i in range(17):
##    print(i,logs[i],logsup[i])
T=[]#список максимумов по k
for i in range(n-k+1):
    T.append(get_mx(i, i+k))
print("mx")
for i in range(LMAXN):
    print(i,mx[i][:nup])
print("mxc")
for i in range(LMAXN):
    print(i,mxc[i][:nup])
print("T")
print(T)
mn=[[0]*(MAXN+1) for i in range(LMAXN)]#заполняем нулями список списков минимумов по степеням 2-ки
mn[0][:len(T)]=T#в нулевом списке максимумы по k, лишние эл-ты - нули
for d in range(1,LMAXN):#перебираем остальные списки(максимумы по 2,4 и т.д.)
    st2=1<<(d-1)#считаем степень 2-ки (по сколько брались максимумы) в предыдущем списке
    for i in range(0,n-st2+1):#перебор номеров эл-тов очередного списка максимумов 
        mn[d][i]=min(mn[d-1][i], mn[d-1][i+st2])#вычисляем максимум по вдвое большему диапазону
s = 0
for i in range(n):
    for j in range(i,n):
        if (i + k >= j):
            s += min(a[i], a[j])
        else:
            rmn=get_mn(i, j - k + 2)
            print(i, j, j-k+2, rmn)
            s += min(get_mn(i, j - k + 2), min(a[i], a[j]))
print("mn")
for i in range(LMAXN):
    print(i,mn[i][:nup])
print(s)
